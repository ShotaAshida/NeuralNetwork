\documentclass{ujarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{listings}
\lstset{%
  language={Python},
  breaklines=true
}
\usepackage{geometry}
\geometry{left=25mm,right=25mm,top=30mm,bottom=30mm}

\title {課題1レポート}

\author{芦田聖太}

\date{提出日　17/12/21}

\begin{document}


\begin{titlepage}
\maketitle
\thispagestyle{empty}
\end{titlepage}


\section*{課題1}
\section{3層のニューラルネットワークの構築}
MNIST の画像 1 枚を入力とし，3 層ニューラルネットワークを用いて，0～9 の値のう
ち 1 つを出力するプログラムを作成する。

\subsection*{仕様}
\begin{itemize}
\item キーボードから 0～9999 の整数を入力 i として受け取り，0～9 の整数を標準出力に
出力すること。
\item MNIST のテストデータ 10000 枚の画像のうち i 番目の画像を入力画像として用いる。
（ただし、MNIST の画像サイズ（28 × 28）,画像枚数（10000 枚）,クラス数（C = 10）は既
知とする。）
\item 中間層のノード数 M は自由に決めて良い。
\item 重み W(1), W(2), b(1), b(2) については乱数で決定すること。ここでは，手前の層の
ノード数を N として 1/N を分散とする平均 0 の正規分布で与えることとする。実行する度に同じ結果を出力するよう乱数のシードを固定すること 。
\end{itemize}


\section{設計方針}
仕様を満たす3層のニューラルネットワークを構築するのに必要なものを以下にあげる。これらを設計し、組み合わせることで3層のニューラルネットワークを構成する。
\begin{itemize}
\item キーボードからの入力処理と画像の取り込み
\item 中間層への入力と出力層の入力の計算
\item シグモイド関数
\item ソフトマックス関数
\end{itemize}

\section{実装}
\subsection{キーボードからの入力処理と画像の取り込み}
X, Yにテストデータを取り込み、Xは(10000, 28, 28)の３次元の配列に整える。Yは正解のラベルの集合なので長さ10000の配列とする。\\
キーボードの入力に関しては、whileループの中で入力をstrnumに格納し、数字が0~9999の場合はbreakする。それ以外の場合はループして0~9999の数字が入力されるまで待つ。break後、Xの入力された番号の画像データ（28 , 28）をindataに格納しさらに（784, 1）の配列へと変換する。\\

main.py
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
# 入力
# 画像取り込み
mndata = MNIST("/Users/omushota/ex4-image/le4nn")
X, Y = mndata.load_testing()
X = np.array(X)
X = X.reshape((X.shape[0], 28, 28))
Y = np.array(Y)


# キーボード入力待ち
while True:
    strnum = input("input number : ")
    num = int(strnum)
    if (num < 0) or (num > 9999):
        print("Please type 0 ~ 9999")
    else:
        break

indata = X[num]
line = X.shape[0]
row = X.shape[1]
indata = np.reshape(indata, (row * row, 1))
\end{lstlisting}


\subsection{中間層への入力と出力層への入力}
中間層への入力と出力層への入力に関しては同じ処理を行うので、中間層への入力についてのみについて述べる。課題2で同じ処理を複数のデータについて行うことを考慮して、中間層への入力を計算する関数を構成した。関数では、入力データ, 中間層の数, 入力層の数, 平均, 分散, シード値を入力とする。まず、np.random.seed(seed)で乱数のシード値を設定することで、実行するたびに同じ乱数が生成されるようにする。次に、row * middleの長さの乱数配列を発生させ、(middle, row)の2次元配列にしweightに格納する。また、同様にmiddleの長さの乱数配列を発生させ、(middle, 1)の2次元配列にしbに格納する。最後に、weightと入力データの積にbを足したものを返す。この関数をmain.pyで用いて中間層への入力とした。\\

layer.py
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
import numpy as np


def mid(indata, middle, row, average, variance, seed):
    np.random.seed(seed)
    weight = np.random.normal(average, variance, row * middle)
    weight = np.reshape(weight, (middle, row))
    b = np.random.normal(average, variance, middle)
    b = np.reshape(b, (middle, 1))
    return weight.dot(indata) + b

def endend(midout, end, middle, average, variance, seed):
    np.random.seed(seed)
    weight1 = np.random.normal(0, variance, middle * end)
    weight1 = np.reshape(weight1, (end, middle))
    b1 = np.random.normal(average, variance, end)
    b1 = np.reshape(b1, (end, 1))
    return weight1.dot(midout) + b1
\end{lstlisting}

main.py
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
# 中間層
middle = 4
average = 0
variance = math.sqrt(1/line)
seed = 100
midinput = mid(indata, middle, row * row, average, variance, seed)

~~~~~~

# 出力層
end = 10
average1 = 0
variance1 = math.sqrt(1/middle)
fininput = endend(midout, end, middle, average1, variance1, seed)
\end{lstlisting}


\subsection{シグモイド関数}
基本的に返り値は計算式のままであるが、入力によって少しだけ出力を変えている。オーバーフローの処理のために、入力が34.538776394910684より大きいときは1.0 - 1e-15を出力する。また、入力が-34.538776394910684より小さいときは1e-15を出力する。そしてそれ以外の時は、1.0 / (1.0 + np.exp(-x))を出力するようにした。\\

sigmoid.py
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
import numpy as np

@np.vectorize

def sigmoid(x):
    sigmoid_range = 34.538776394910684
    if x <= -sigmoid_range:
        return 1e-15
    if x >= sigmoid_range:
        return 1.0 - 1e-15
    return 1.0 / (1.0 + np.exp(-x))
\end{lstlisting}

\subsection{ソフトマックス関数}


softmax.py
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
import numpy as np


def softmax(a):
    c = np.max(a)
    exp_a = np.exp(a - c)
    sum_exp_a = np.sum(exp_a)
    y = exp_a / sum_exp_a

    return y
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single]
\end{lstlisting}

\begin{center}
\end{center}


\end{document}